<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小贺的博客</title>
    <link>https://he2121.github.io/xiaohe-blog/</link>
    <description>Recent content on 小贺的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 02 Mar 2022 00:38:28 +0800</lastBuildDate><atom:link href="https://he2121.github.io/xiaohe-blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>字符编码发展梳理</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%8F%91%E5%B1%95%E6%A2%B3%E7%90%86/</link>
      <pubDate>Wed, 02 Mar 2022 00:38:28 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%8F%91%E5%B1%95%E6%A2%B3%E7%90%86/</guid>
      <description>从 Golang 中的字符串出发
  len(&amp;quot;ab你好&amp;quot;) 返回多少
  已经存在用下标遍历字符串的方式，为什么还要有for _,ch range str ，有什么区别
  从 ASCII 字符编码到 UTF-8 🔗起点: ASCII 码 🔗首先我们知道在计算机的世界中，一切数据都是以字节流的形式存在。例如下图，一个字节（8 个 bit）可以表示从 0 - 255 之间的整数。
但是我如果想表示一个字符呢？
字符定义：
 在电脑和电信领域中，字符（Character）是一个信息单位。对使用字母系统或音节文字等自然语言，它大约对应为一个音位、类音位的单位或符号。简单来讲就是一个汉字、假名、韩文字……，或是一个英文、其他西方语言的字母。字符的例子有：字母、数字系统或标点符号。
 此时需要一个字符与整数之间的映射关系。例如，用整数 97 -&amp;gt; a。你传入一个整数，并且指明这个整数是字符类型，那么计算机就给你显示成字符
这时候最通用的 ASCII (American Standard Code for Information Interchange，美国信息交换标准代码) 在 1963 年由美国国家标准协会提出。
最初版 ASCII 编码使用一个字节中的 7 个 bit 位 （整数 0-127）定义了整数到 128 个字符的映射关系。 ASCII 定义的 128 个字符与其编码方式如下图所示。
编码范围 🔗十进制: 0-127
字节形式：
ASCII 意义 🔗包含了使用最广泛的控制字符、数字符号、英文字母、英文符号，作为鼻祖，成为计算机编码系统的基础，以后出现的各种字符编码基本都要兼容它</description>
    </item>
    
    <item>
      <title>小狗钱钱读后感</title>
      <link>https://he2121.github.io/xiaohe-blog/reading/%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1%E8%AF%BB%E5%90%8E%E6%84%9F/</link>
      <pubDate>Tue, 15 Feb 2022 11:10:12 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/reading/%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1%E8%AF%BB%E5%90%8E%E6%84%9F/</guid>
      <description>这本书我不到 2 小时读完了，适用于投资小白阅读，对于我这种已经进入股票交易一年多人来说，内容偏简单
核心思想 🔗  行动力
  强制储蓄
  基金理财
  记忆深刻的两点 🔗 鹅生蛋: 每个人都要有自己的鹅来生蛋。目前我的钱 90% 以上都在股市，实际上不是一种好的鹅，而是一种很可能会死的鹅。但目前我的资本少，能接受亏损，主要是想快速扩张资本。但后期应无论何时都要保障一定的现金流 72 法则：想重点分析下这个法则  72 法则 🔗意义：快速计算你资本在理财复利情况下，多少年能翻倍。
如：
 一只基金稳定年收益率 10%，需要 72/10 = 7.2 年，翻倍 假设我国通货膨胀在 3% 每年，需要 72/3 = 24 年，你的钱损失一半  72 法则如何计算得来？
假设利率为 m，需要 n 年后本金才能翻倍，可得下面等式 $$ (1+m)^n = 2 $$ 现在需要计算 n，取 ln $$ n*ln(1+m) = ln2 $$ 移项 $$ n = \frac{ln2} {ln(1+m)} $$ ln(1+m) 泰勒展开式 (高等数学，任何表达式都能用一个二项式来近似) $$ ln(1+𝑥)=𝑥−\frac{𝑥^2}{2}+\frac{𝑥^3}{3}−\frac{𝑥^4}{4}+⋯, $$ 理财一般利率会在 0.</description>
    </item>
    
    <item>
      <title>红楼梦关于高鹗续写后 40 回个人想法</title>
      <link>https://he2121.github.io/xiaohe-blog/reading/%E7%BA%A2%E6%A5%BC%E6%A2%A6/%E7%BA%A2%E6%A5%BC%E6%A2%A6%E5%85%B3%E4%BA%8E%E9%AB%98%E9%B9%97%E7%BB%AD%E5%86%99%E5%90%8E-40-%E5%9B%9E%E4%B8%AA%E4%BA%BA%E6%83%B3%E6%B3%95/</link>
      <pubDate>Sun, 13 Feb 2022 11:10:12 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/reading/%E7%BA%A2%E6%A5%BC%E6%A2%A6/%E7%BA%A2%E6%A5%BC%E6%A2%A6%E5%85%B3%E4%BA%8E%E9%AB%98%E9%B9%97%E7%BB%AD%E5%86%99%E5%90%8E-40-%E5%9B%9E%E4%B8%AA%E4%BA%BA%E6%83%B3%E6%B3%95/</guid>
      <description>“宝玉，你为什么病了？”
宝玉笑道：“我为林姑娘病了”
 来自高鹗续写 105 回
最近刚读完红楼梦全集，在此留下一些个人想法
![image-20220213195723422](/Users/bytedance/Library/Application Support/typora-user-images/image-20220213195723422.png)
后 40 回相关的 🔗 续写部分超出个人预期，除开最开始几回目比较生疏，后面渐入佳境，完全无烂尾的迹象 个人认为高鹗起码读过相当部分残稿，要不然写不出这些情节 宝玉丢玉，被骗结婚，黛玉在宝玉结婚当天死亡的回目非常精彩，描写他们之间的爱情部分达到了全文的高潮 后续贾家败亡情节也令人唏嘘，主要人物也依次下场，却在最后结尾明确了贾家复兴的希望 总之不像网上评论的那样，值得一看  不满意的地方 🔗贾母对黛玉的态度转换太快了 🔗前面看着贾母是很挺爱黛玉，支持宝黛的。
后面支持哄骗宝玉取宝钗，黛玉快死了也不去看望。虽说书中写了贾母相对外孙女更看重宝玉，但个人还是难以接受贾母会无视黛玉的性命。
探春无戏份了 🔗前面的情节，让我非常喜欢探春。高鹗的续写部分，探春只有出嫁。。。
人物评价 🔗贾政 🔗一开始就知道谐音梗 “假正经”，以为是个反面人物。不过一路看下来，个人还是挺喜欢他的。
有底线、有道德，但是缺少手段，处处被人欺骗。作为官，算是个清官，但是无法阻止手下的贪婪。作为家族家长，想管事，但无能力，被底下人欺骗。作为父亲，其实对宝玉挺好，就是有点迂腐。
能感觉到他是个有情的人，在听闻黛玉死去的消息，他这死板的人也不免流泪，和疼黛玉的贾母形成对比。这或许就是传统的中国大家长了，而且我总有种感觉贾政就是长大后的宝玉
贾琏 🔗好色
但他确是贾府年轻一辈中最靠谱的一个了，后期贾府基本就是他和王熙凤在当救火员了。而且他和王熙凤之间也是真爱情了，能看出他们之间的感情。王熙凤也是搞了不少事，他也都兜着（虽然有怨言）。</description>
    </item>
    
    <item>
      <title>Golang Select 关键词详解</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/golang/golang-select-%E5%85%B3%E9%94%AE%E8%AF%8D%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 28 Jan 2022 17:10:12 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/golang/golang-select-%E5%85%B3%E9%94%AE%E8%AF%8D%E8%AF%A6%E8%A7%A3/</guid>
      <description>背景 🔗在分析 Golang channel 源码时 todo</description>
    </item>
    
    <item>
      <title>kmp 算法</title>
      <link>https://he2121.github.io/xiaohe-blog/algorithm/kmp-%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 23 Jan 2022 17:10:12 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/algorithm/kmp-%E7%AE%97%E6%B3%95/</guid>
      <description>KMP 相关题目 🔗  28. 实现 strStr()
  459. 重复的子字符串
  686. 重复叠加字符串匹配
  基本思想 🔗KMP 算法是字符串匹配中经典算法，由 Knuth，Morris 和 Pratt 发现，所以取了三位学者名字的首字母，叫做KMP 算法
以 28. 实现 strStr() 为例
 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。
 我们普通人的暴力破解思路：
func strStr(haystack string, needle string) int { if len(needle) == 0 { return 0 } for i := 0; i &amp;lt;= len(haystack) -len(needle); i ++ { j := 0 for ; j &amp;lt; len(needle); j ++ { if haystack[i + j] !</description>
    </item>
    
    <item>
      <title>流处理系统简介</title>
      <link>https://he2121.github.io/xiaohe-blog/reading/ddia/%E6%B5%81%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 20 Jan 2022 11:10:12 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/reading/ddia/%E6%B5%81%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/</guid>
      <description>主要内容来自 DDIA 第十一章 流处理系统，还有自己关于 Golang 流计算的一些调研
 背景 🔗计算服务可按以下方式分为三类：
  在线服务：当收到请求时，服务尽可能快的处理并且发挥一个响应，如常见 Web 服务。
  批处理(离线)系统：一次性接收并处理大量的数据，往往需要执行比较长的时间（几分钟到几天），所以用户不会同步等待返回结果，这种作业一般定期执行。最常见是 MapReduce
  流处理（近实时）系统：流处理介于在线与离线之间。批处理输入是有界的，而流处理的输入是无界的。当有新事件到达时，流系统就会处理。比较流行的流处理系统有 Storm， Spark，Flink
  今天我们来简要介绍下流式处理，尤其是其中流分析相关的部分
流式处理的适用场景 🔗一般用于实时监控报警
 复杂事件处理，允许指定规则，从而在流中搜索特定模式的事件。使用像 SQL 这样的声明式语言来描述应该检验的事件模型 流分析，其与复杂事件处理之间的界限有些模糊。主要差别在其不关心特定序列，更多面向大量数据的累计效果与统计指标，例如，测量某种事件的速率，一段时间内某个值的平均值等 维护物化视图，使用数据库更改流（如 binlog 流）来保持派生数据系统 &amp;hellip;  流处理系统一些难点 🔗1. 时间问题 🔗流处理需要和时间打交道，尤其在用于流分析时，如 “最近 5 分钟的平均值”，这个 “最后 5 分钟” 的定义其实非常模糊，处理起来非常麻烦。在流处理框架，一般使用两种时间：
 事件处理时间，流处理框架处理这个事件时的本地系统时钟 事件发生时间，事件自己记录的发生时间  事件处理时间一般要比事件发生时间延迟一些。例如 A 事件发生 00:00, 经过消息队列，到达流处理系统时处理时间为 00:03 了。
时间窗口该使用哪个定义？这时候就需要使用者根据自己系统的特点和使用目的做一些取舍了。
  使用事件处理时间，这种方式的优点是简单，并且在发生时间与处理时间之间延迟不大的情况下，效果非常好。
  使用事件发生时间，可以使处理过程是确定性的：基于同一个输入，再次运行相同的处理过程可以得到相同的处理结果。这样能够支持流批一体，并且能够处理发生时间与处理时间之间延迟很大的情况。
  使用事件发生时间的缺点是其实现比较复杂，例如无法确定什么时候能够收到特定窗口内的所有事件。一般有两种处理方式：</description>
    </item>
    
    <item>
      <title>数据编码与演化</title>
      <link>https://he2121.github.io/xiaohe-blog/reading/ddia/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E4%B8%8E%E6%BC%94%E5%8C%96/</link>
      <pubDate>Sun, 16 Jan 2022 14:30:00 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/reading/ddia/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E4%B8%8E%E6%BC%94%E5%8C%96/</guid>
      <description>本文主要内容来自于《数据密集型应用系统设计》 第四章，推荐大家看原作
 背景 🔗在程序中，数据有两种不同的表示形式
  在内存中的数据结构： 对象，结构体，列表，数组，散列表，树等。
  如果要把内存中的数据结构保存到文件，或通过网络发送，则需要转换成字节序列（如 JSON ）
  两种不同表示的数据之间经常需要进行转换，从内存中数据结构转成字节序列成为 编码（encode）、序列化（serialization） 或 编组（marshalling）。反过来被称为 解码（Decoding） 、 **反序列化（deserialization）**或者 反编组( unmarshalling）
数据编码与演化 🔗1. 语言特定的格式 🔗首先比较常见的是各个编程语言内置对序列化的实现。例如 Python 中的 pickle、 Java 中的 java.io.Serializable 、Golang 中的 gob&amp;hellip;
但除非临时尝试中，我们一般不会使用它们。这是由于：
 这类编码通常与特定的编程语言深度绑定，其他语言很难读取这种数据，很难将系统与其他组织的系统（可能用的是不同的语言）进行集成 为了恢复相同对象类型的数据，解码过程需要实例化任意类的能力，这通常是安全问题的一个来源 在这些库中，数据版本控制通常是事后才考虑的。因为它们旨在快速简便地对数据进行编码，所以往往忽略了前向后向兼容性带来的麻烦问题 效率（编码或解码所花费的CPU时间，以及编码结构的大小）往往也是事后才考虑的。 例如，Java的内置序列化由于其糟糕的性能和臃肿的编码而臭名昭着  2. JSON、XML 文本格式编码 🔗现在比较常用的 JSON、XML 两种文本格式编码，其最大优点的是可以被多种编程语言读写， CSV 是另一种流行的与语言无关的格式，但其其功能相对较弱。下面是内存中的一个对象被编码成 JSON 格式后的示例，使用文本格式编码，不仅可以被多种编程语言解码（decoding），甚至连我们人类都能直接阅读理解其意思。
{ &amp;#34;userName&amp;#34;: &amp;#34;Martin&amp;#34;, &amp;#34;favoriteNumber&amp;#34;: 1337, &amp;#34;interests&amp;#34;: [&amp;#34;daydreaming&amp;#34;, &amp;#34;hacking&amp;#34;] } JSON、XML 得到了广泛的应用，但也有不少问题。例如 XML 格式的复杂与冗长。JSON 的流行则主要源于（通过成为JavaScript的一个子集）Web浏览器的内置支持，以及相对于XML的简单性。下面列数了它们的一些问题</description>
    </item>
    
    <item>
      <title>Golang 逃逸分析</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/golang/golang-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 12 Jan 2022 16:10:12 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/golang/golang-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</guid>
      <description>问题 🔗 Go 中 New/Make 出来的对象存在哪，栈还是堆？ 下面 FooA 与 FooB 函数哪个性能高一点，为什么(来自 stack overflow)？  package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) type User struct { Name string Age int } func main() { fooA() fooB() } func fooA() { start := time.Now() var c = make(chan User, 1024) for i := 0; i &amp;lt; 1024; i ++ { user := User{Name: &amp;#34;he&amp;#34;, Age: 25} c &amp;lt;- user } since := time.</description>
    </item>
    
    <item>
      <title>日志结构流派存储引擎的演化</title>
      <link>https://he2121.github.io/xiaohe-blog/reading/ddia/%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E6%B5%81%E6%B4%BE%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E6%BC%94%E5%8C%96/</link>
      <pubDate>Fri, 07 Jan 2022 14:30:00 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/reading/ddia/%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E6%B5%81%E6%B4%BE%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E6%BC%94%E5%8C%96/</guid>
      <description>本文主要内容来自于《数据密集型应用系统设计》 第三章，内容对我很有启发，所以分享给大家，推荐看原作。
 背景 🔗存储引擎存在着两个主要流派：
 日志结构流派，只允许追加式更新/删除文件，不会修改已写入的文件，Bitcast，SSTables，LSM-Tree，LevelDB，RocksDB，Cassandra，HBase，Lucene 等属于此类 原地更新流派，将磁盘视为可以覆盖的一组固定大小的页。B-tree 就是这一流派的典型代表，已用于所有主流关系型数据库，以及大量的非关系数据库  大部分人已经对原地更新流派中 B-tree 已经比较熟悉了，但对日志结构流派并不是很了解，本文带领大家了解下其演化过程及 LSM-tree 与 B-tree 的对比
演化过程 🔗1. 一个最简单的数据库 🔗基本原理 🔗由两个 Bash 函数实现：
db_set(){ echo &amp;#34;$1,$2&amp;#34; &amp;gt;&amp;gt; database } db_get(){ grep &amp;#34;^$1,&amp;#34; database | sed -e &amp;#34;s/^$1,//&amp;#34; | tail -n 1 } 插入/更新数据: 往 database 文本中追加一行 &amp;lt;key，value&amp;gt;
查询数据： 查找文本中最后一次出现的 &amp;lt;key，value&amp;gt;
例如：
➜ ~ db_set key1 val1 ➜ ~ db_set key2 val2 ➜ ~ db_set key1 val3 ➜ ~ cat database key1,val1 key2,val2 key1,val3 ➜ ~ db_get key1 val3 局限性 🔗db_set: 追加式写，性能高。但db_get: 从头扫描到尾，性能很差</description>
    </item>
    
    <item>
      <title>2022 读书计划</title>
      <link>https://he2121.github.io/xiaohe-blog/reading/2022%E8%AF%BB%E4%B9%A6%E8%AE%A1%E5%88%92/</link>
      <pubDate>Wed, 05 Jan 2022 14:08:32 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/reading/2022%E8%AF%BB%E4%B9%A6%E8%AE%A1%E5%88%92/</guid>
      <description> 之前学习新知识总是游离在网上博客，学习到的各个知识点都是零散的。所以今年决定读一些纸质书，增强下自己的底蕴。读完每一本书至少输出一篇博客，分享自己的收获或者对这本书的评价。
 技术类 🔗已读完 🔗 DDIA 数据密集型应用系统设计  正在进行中 🔗 Redis 设计与实现 Go专家编程  待安排 🔗 高性能 MySQL TCP/IP 第一卷 计算机程序的构造和解释 重构（第2版） 领域驱动设计 代码整洁之道  非技术类 🔗已读完 🔗 红楼梦 小狗钱钱  正在进行中 🔗 家庭、私有制和国家的起源 巴菲特致股东的信  待安排 🔗 毛选 亲密关系 原则  </description>
    </item>
    
    <item>
      <title>2022度博客每周回顾</title>
      <link>https://he2121.github.io/xiaohe-blog/mixed/2022%E5%BA%A6%E5%8D%9A%E5%AE%A2%E6%AF%8F%E5%91%A8%E5%9B%9E%E9%A1%BE/</link>
      <pubDate>Wed, 05 Jan 2022 14:08:32 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/mixed/2022%E5%BA%A6%E5%8D%9A%E5%AE%A2%E6%AF%8F%E5%91%A8%E5%9B%9E%E9%A1%BE/</guid>
      <description>每周两篇博客，坚持！
1.3 - 1.9 🔗 Raft 2D 日志结构流派存储引擎的演化  1.10 - 1.16 🔗 Golang 逃逸分析 数据编码与演化  1.17 - 1.23 🔗 流系统简介 kmp 算法  1.24 - 1.30 🔗 年假前偷懒了  1.31 - 2.6 🔗 年假  2.7 - 2.13 🔗2.14 - 2.20 🔗2.21 - 2.27 🔗2.28 - 3.6 🔗3.7 - 3.13 🔗</description>
    </item>
    
    <item>
      <title>6.824 README</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/6.824/readme/</link>
      <pubDate>Mon, 03 Jan 2022 14:30:00 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/6.824/readme/</guid>
      <description>MIT6.824-2021 🔗MIT6.824 Distributed Systems Engineering 2021 个人学习记录
仓库地址
官方地址
B 站视频学习
个人博客在线阅读
声明：
 不生产知识，只是知识的搬运工 遵循协议实验代码不公开，但博客中会记录个人实现思路 在每个翻译文档开头都放了原链接，若翻译不行（我也大部分都是翻译器复制的），请直接查看原文档  文件夹说明：
docs-cn --&amp;gt; 官方 note，lab 中文翻译 my-blog	--&amp;gt; 个人学习过程想法，笔记记录，lab 实现等相关博客 个人博客是根据实验来写的，如果想快速完成实验，可以从我博客开始，我会给出我的实验前的准备与实现中的思路。
如有文档中存在错误/想参与此项目（翻译文档/实验实现思路），请：
 直接提 issue / mr 发邮件联系 1070259395@qq.com 6.824 讨论群【todo】  导航目录: 已完成（个人实现部分）：
 Lab1-MapReduce-实现过程 Lab2A&amp;amp;2B-Raft-leader选举与日志同步-实现过程 Lab2C-Raft-持久化状态与日志同步优化-实现过程 Lab2D-Raft-快照-实现过程  已完成（翻译部分）：
 Lecture-01-笔记-MapReduce-翻译 Lecture-02-笔记-Go并发-翻译 Lecture-06-笔记-Raft(1)-翻译 Lab1-实验文档-MapReduce-翻译 Lab2-实验文档-Raft-翻译  Todo（翻译部分）：
 Lecture-07-笔记-Raft(2)-翻译 Lab3-实验文档 &amp;hellip;  Todo（个人实现部分）：
 lab 3 lab 4  如有帮助到你，期待一颗 star</description>
    </item>
    
    <item>
      <title>Lab2D-Raft-快照-实现过程</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/6.824/6.824-lab2d%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Mon, 03 Jan 2022 14:30:00 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/6.824/6.824-lab2d%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/</guid>
      <description>实现前准备 🔗必看 🔗 raft论文 Log compaction 部分 Lab2-实验文档-Raft-翻译Lab2-实验文档-Raft-翻译 2D 交互图  Lab 2D 实验目标 🔗问题 🔗  一个长期运行的服务，不可能永远能存下庞大的 Log
  服务重启后，上层应用每次都需要从头到尾执行一次全部 Log，这个恢复速度太慢
  解决 🔗 服务通过不时保存一下它的快照（SnapShot），然后告诉 Raft 快照点之前的日志可以丢了 使：1. Raft 不必维持所有 Log 2. crash 恢复速度也很快速  Lab 2D 实现 🔗我的理解 🔗下图是论文中给出的图，它很形象，让我们一下理解快照的含义。但是这个图给了我一个错觉：快照是经过 log 压缩产生的。然而这是错误的，快照是由上层服务产生，传给 raft 层，然后让 Raft 层丢弃这之前的日志。
下面的交互图更加准确，让我们了解到数据流通的方向
 Snapshot(index int, snapshot []byte)：这里由上层服务触发，把保存快照传过来，raft 保存快照，裁剪冗余日志 InstallSnapshot(args *InstallSnapshotArgs, reply *InstallSnapshotReply) : 这是个 RPC handler，通常为 Follower 落后leader 太多时触发，leader 向 Follower 发起请求，让 Follower 上层服务安装 leader 的快照快速跟上节奏。 CondInstallSnapshot(lastIncludedTerm int, lastIncludedIndex int, snapshot []byte) bool: 这是属于 InstallSnapshot RPC 的延续，RPC 在上层服务安装快照后，会触发这个接口更新 Raft 的状态。  State 🔗 首先我们需要在 Raft 实例中加入跟快照相关的状态  // For 2D 快照 	lastIncludedIndex int // 保存到快照中的最后一个 Log 的 index 	lastIncludedTerm int // 保存到快照中的最后一个 Log 的 term 	snapshot []byte // 保存的最近一个快照 既然 logs 不保存所有 log 了，操作相关 logs 的方法也需要修改(把快照中 log 算上)  func (rf *Raft) getLastIndex() int { return len(rf.</description>
    </item>
    
    <item>
      <title>Lab2C-Raft-持久化状态与日志同步优化-实现过程</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/6.824/6.824-lab2c%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Sat, 01 Jan 2022 14:30:00 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/6.824/6.824-lab2c%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/</guid>
      <description>如果你把 Lab 2B 一步步调过来了，2C 对于你几乎没有难度
 实现前准备 🔗必看 🔗 raft论文 Safety、持久化、AppendEntries 优化 Lab2-实验文档-Raft-翻译Lab2-实验文档-Raft-翻译 2C  Lab 2C 目标 🔗 持久化 state，使 server 重启时能够恢复 优化 AppendEntires RPC 被拒绝的次数，之前我们使用 prevLogIndex - 1 来慢慢匹配日志的位置，很明显性能不够  LAB 2C 实现 🔗持久化 state 🔗需要持久化的 state 在图 2 中进行了说明，分别是：
  currentTerm：当前任期, 这个肯定需要持久化
  voteFor：这里持久化的目的是，避免一次任期投两次票
  logs：日志，重启回复需要重新执行一次命令
  因此代码中修改了上述三个变量的地方都要进行一次持久化。
持久化一般到磁盘中，但在这个 lab，使用了 persister 来模拟，方便测试。
 读取持久化状态  // // restore previously persisted state. // func (rf *Raft) readPersist(data []byte) { if data == nil || len(data) &amp;lt; 1 { // bootstrap without any state?</description>
    </item>
    
    <item>
      <title>Lab2A&amp;2B-Raft-leader选举与日志同步-实现过程</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/6.824/6.824-lab2a-2b%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Tue, 28 Dec 2021 14:30:00 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/6.824/6.824-lab2a-2b%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/</guid>
      <description>Raft 实现真的比较难，首先要从整体上完全理解 Raft 的运行机制就比较困难。再具体到实现上，涉及到很多个后台 goroutine（goroutine 中起 goroutine），如何加锁才能安全读取写入共享变量（一不小心还死锁），并发难以 debug，计时器的实现&amp;hellip; 这篇文章记录下我的个人经验把，希望对其他人能有所帮助
 实验前 🔗必看 🔗  raft论文 leader 选举和 Log 复制部分
  Lab2-实验文档-Raft-翻译Lab2-实验文档-Raft-翻译 2A 2B
  Lecture-06-笔记-Raft(1)-翻译 Lecture-07-笔记-Raft(2)-翻译
  选看 🔗 lec 3,4 课程视频 lec 6, 7  建议 🔗  lecture 3 讲 GFS，lecture 4 讲一个复制容错的论文。与我们要实现的 raft 的关系不大，最多算一些前置知识，建议不看。
  建议 lab2A 与 lab2B 一起做，虽然 lab2 文档把 lab 分开为两个部分。但是我们是去对照论文实现，尤其在 RequestVote 与 AppendEnties 两个 RPC 中，这两者混杂在一起
  多读几遍论文与 lab2 文档，尤其是论文中的图 2, 再开始 lab&amp;hellip;</description>
    </item>
    
    <item>
      <title>Golang 汇编介绍</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/golang/golang-%E6%B1%87%E7%BC%96%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Wed, 22 Dec 2021 16:10:12 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/golang/golang-%E6%B1%87%E7%BC%96%E4%BB%8B%E7%BB%8D/</guid>
      <description>在阅读 Golang 源代码时，总是被其中的汇编代码卡住，读起来不流畅。今天来简要了解下 Golang 中的汇编语言。
 汇编分类 🔗按指令集架构分类（针对 CPU） 🔗  x86汇编(32bit):这种架构常被称为i386, x86
  x86汇编(64bit), 这种架构常被称为 AMD64, Intel64, x86-64, x64, 它是 AMD 设计的, 是 x86 架构的 64 位扩展, 后来公开
  ARM汇编, ARM处理器由于高性能, 低耗电, 常用于嵌入式, 移动设备.
  &amp;hellip;
  按汇编格式分类（针对人的阅读习惯） 🔗 Intel 格式 AT&amp;amp;T 格式  平时我们说 golang 中汇编属于 plan9 风格，是按第二种方式分类的，其阅读风格（符号）与 Intel 与 AT&amp;amp;T 都有不同。plan9 汇编作者是 unix 操作系统的同一批人，bell 实验室所开发的。
Go汇编语言是基于 plan9 汇编，但是现实世界还有这么多不同架构的 CPU 在这。所以 golang 汇编在 plan9 风格下，同一个方法还有不同指令集架构的多种实现。</description>
    </item>
    
    <item>
      <title>云服务器可以干什么系列: vscode 远程开发调试</title>
      <link>https://he2121.github.io/xiaohe-blog/mixed/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E5%B9%B2%E4%BB%80%E4%B9%88%E7%B3%BB%E5%88%97-vscode-%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95/</link>
      <pubDate>Thu, 16 Dec 2021 20:39:11 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/mixed/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E5%B9%B2%E4%BB%80%E4%B9%88%E7%B3%BB%E5%88%97-vscode-%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95/</guid>
      <description>为什么需要远程开发调试 🔗 本地开发环境设置复杂 本地操作系统 windows/mac 开发体验、兼容不佳 多设备共享一个开发环境，切换设备开发体验好  如何设置 🔗 本地已安装 vscode，并以安装好开发语言插件（代码提示，补全&amp;hellip;） ssh 能连接上远程开发机，并且远程开发机安装好开发环境（如安装好 Git，Go） vacode 插件市场搜索安装 Remote Development  cmd + shift + p 搜索 Remote-SSH: Add New SSH Host 输入 ssh user@IP 添加 ssh 连接记录。 cmd + shift + p 搜索 Remote-SSH: Connect to Host，选择需要连接的 IP 进行连接。然后弹出的 vscode 界面即是远程开发的环境了  </description>
    </item>
    
    <item>
      <title>Lab1-MapReduce-实现过程</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/6.824/6.824-lab1%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Thu, 16 Dec 2021 14:30:00 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/6.824/6.824-lab1%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/</guid>
      <description>最近在学习 MIT 6.824 分布式系统课程，以 lab 维度记录自己的学习心得。
 前置准备 🔗6.824 官方课程安排链接
基础技能 🔗 Go Git  实验前必看 🔗 MapReduce 论文 Lecture-01-笔记-MapReduce-翻译 Lab1-实验文档-MapReduce-翻译这个是重点，跟着这个做实验  选看 🔗 课程视频 Lecture-02-笔记-Go并发-翻译  建议 🔗个人认为看视频比较花费时间，对自己比较自信的话，直接看课程笔记了解一下即可。
对于实验一 MapReduce 需要我们需要先学习 lecture 1 与 2 的内容。
 Lecture 1 前半段是课程介绍，大致了解就行。后半段讲的 MapReduce，需仔细学习。 Lecture 2 讲的 Go 多线程 与 RPC，如果已经对 Go 比较熟悉，这里可跳过。  实验过程 🔗1. 实验环境 🔗 跟着 lab1 中的 Getting started（入门），跑通实验环境(go build不出错 ) 熟悉 main/mrsequential.go 代码  在 MapReduce 这个实验中中，使用了 Go 的 plugin（此处应有文档介绍） 把实际的应用程序做成了可插拔式的。但由于 Go 的 plugin 现在比较鸡肋，在 Mac/windows 开发环境中可能会出现各种奇怪问题。建议使用 远程开发 进行开发。</description>
    </item>
    
    <item>
      <title>分布式链路追踪 Jaeger 快速入门-01</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AAjaeger%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-01/</link>
      <pubDate>Thu, 09 Dec 2021 14:30:00 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AAjaeger%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-01/</guid>
      <description>Logging，Metrics 与 Tracing 关系 🔗同：都是为了提高基础设施和应用程序的可观测性
区别：
   &amp;mdash;- Logging Metrics Tracing     特点 记录离散的事件 记录可聚合的数据 记录请求范围内的信息   典型指标 用户自行打印的调试信息&amp;hellip; QPS, 接口时延分布 一个具体 RPC 调用中的过程：各个服务的耗时占比   典型应用 ELK(收集，分析), log4j（记录）&amp;hellip; Prometheus&amp;hellip; Dapper, OpenZipkin,Jaeger&amp;hellip;    它们之间有重叠，但各自关注的重点不同
OpenTracing 是什么 🔗 当今乃是微服务的天下，Tracing 是给跨进程、服务的追踪提供了一种解决方案 OpenTracing API 提供了一个标准的、厂商中立的规范。其允许系统中存在多种分布式追踪方案 - 只要符合规范  OpenTracing 数据模型 🔗Trace(调用链)：一个调用链代表一个事务或者流程在（分布式）系统中的执行过程。在OpenTracing标准中，调用链是多个Span组成的一个有向无环图（Directed Acyclic Graph，简称DAG）
Span(跨度)：一个名字、有时间的操作，代表工作流程的一个部分。span 上一般有以下信息：span 名字，span 起始时间、结束时间，tag，log，span context，span 之间的引用关系。
SpanContext：伴随着分布式的跟踪信息，它通过网络或通过消息总线透传上下文信息。span 上下文包含 tracing 标识符、span 标识符以及追踪系统需要传播给下游服务的任何其他数据。
span 之间的关系：</description>
    </item>
    
    <item>
      <title>Prometheus 快速入门-02</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/prometheus-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-02/</link>
      <pubDate>Wed, 08 Dec 2021 14:30:00 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/prometheus-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-02/</guid>
      <description>数据模型 🔗Prometheus 底层将所有数据存储为时间序列: 即以相同 metric 和 label 维度聚合的带时间戳的流。
时序格式 🔗下面格式表示一个 metric 和 label 的时序数据集合
&amp;lt;metric name&amp;gt;{&amp;lt;label name&amp;gt;=&amp;lt;label value&amp;gt;, ...} 例如，一个时间序列的度量名称 api_http_requests_total 和 label 方法=&amp;ldquo;POST&amp;rdquo; 和handler=&amp;quot;/messages&amp;quot;可以写成这样:
api_http_requests_total{method=&amp;#34;POST&amp;#34;, handler=&amp;#34;/messages&amp;#34;} 采样 🔗Prometheus 通过 pull 收到各个 metric 的实际数据，样本形成实际的时间序列数据，每个样本包括:
  float64值
  一个毫秒精度时间戳
  小结 🔗 Prometheus 以 metric 和 label 的维度聚合时序数据 Prometheus 以 pull 方式，收集各个监控目标上 metric 的值与时间戳  Metric 类型 🔗Prometheus Metric 有四种类型：Counter，Gauge，Histogram，Summary
Counter 🔗  特性：只增不减
  适用：服务请求数、已完成任务数、错误出现次数等
  示例：http 请求数</description>
    </item>
    
    <item>
      <title>Prometheus 快速入门-01</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/prometheus-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-01/</link>
      <pubDate>Mon, 06 Dec 2021 14:30:00 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/prometheus-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-01/</guid>
      <description>Prometheus 是什么 🔗Prometheus 是 SoundCloud 公司开源的系统监控告警工具。2016 年，继 k8s 后，作为第二个托管项目加入了云原生计算基金会。这个项目拥有着非常活跃的开发者和用户社区，随着云原生和 k8s的推广，越来越多的公司的运维都是使用 Prometheus + Grafana（可视化） 的这一套。
Prometheus 以时序数据的形式收集和存储其指标，同时支持添加自定义 label 的可选键值对
监控对象 🔗 硬件状态：电源状态、CPU 状态、机器温度、风扇状态&amp;hellip; 服务器基础：CPU，内存，磁盘，网络 使用情况 数据库: MySQL, ES &amp;hellip; 中间件：Nginx, MQ.. 应用：QPS，接口延时，线程数&amp;hellip;  Prometheus 优势 🔗其他方案
 Zabbix: 1998 年诞生&amp;hellip; 属于传统主机监控，主要用于物理主机，交换机，网络等监控 Graphite: 专注于两件事，存储时序数据， 可视化数据, 其它功能都要安装插件实现, Prometheus 功能丰富：趋势，查询&amp;hellip; InfluxDB: 时序数据库&amp;hellip; 监控部分自己搞，prometheus 不仅仅局限于存储时序数据 Nagios：90 年代诞生&amp;hellip; Sensu ：可以看作 Nagiosde 的升级版本 Open-falcon：小米开源，社区活跃度一般  优势
 云原生支持好，K8s 和 Etcd 等一列项目都提供了对 Prometheus 的原生支持，是目前容器监控最流行的方案 Prometheus 属于一站式监控告警平台，依赖少，功能齐全。 多维数据模型，聚合统计更方便 强大的查询语句  劣势</description>
    </item>
    
    <item>
      <title>vim 常见命令记录</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/tools/vim-%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 06 Dec 2021 14:30:00 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/tools/vim-%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</guid>
      <description>跳转到文件 🔗  头: gg
  尾：G
  50 行：50G
  跳转到行首/尾 🔗  首: ^(shift + 6) / 0(包括空格)
  尾：$(shift + 4)
  跳转到下一个单词：w 🔗复制 🔗  复制一行：yy
  向下复制 10 hang：10yy
  粘贴：p 🔗撤销：u 🔗翻页 🔗  下一页：ctr + f
  上一页：ctr + b
  搜索 🔗 : ?  </description>
    </item>
    
    <item>
      <title>Golang 的骚操作：go:linkname</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/golang/golang-%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9Clinkname/</link>
      <pubDate>Thu, 02 Dec 2021 17:10:12 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/golang/golang-%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9Clinkname/</guid>
      <description>背景 🔗 在看源码时，一些源码方法没有方法体，难道说明这些方法为空？例如：time.Now 调用的 now(), time.Sleep , reflect.makechan  // Provided by package runtime. func now() (sec int64, nsec int32, mono int64) func Sleep(d Duration) func makechan(typ *rtype, size int) (ch unsafe.Pointer) 在写代码时，如果我们想使用别的包下没有导出的方法或者变量时，怎么操作  go:linkname 的用法 🔗实际上，上述提到的三个没有方法体的方法，其实现都在 src/runtime包下
 time.now timestub.go 文件中  //go:linkname time_now time.now func time_now() (sec int64, nsec int32, mono int64) { sec, nsec = walltime() return sec, nsec, nanotime() } time.Sleep time.go 文件中  // timeSleep puts the current goroutine to sleep for at least ns nanoseconds.</description>
    </item>
    
    <item>
      <title>Golang channel 原理介绍</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/golang/golang-channel-%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Mon, 29 Nov 2021 17:10:12 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/golang/golang-channel-%E4%BB%8B%E7%BB%8D/</guid>
      <description>问题 🔗 从关闭的 channel 读取数据，如以下情况输出什么。如果是发送数据，再关闭一次 channel的操作呢？怎么判断 channel 的是否关闭  func main() { ch := make(chan int,2) ch &amp;lt;- 1 close(ch) num1, ok1 := &amp;lt;- ch num2,ok2 := &amp;lt;- ch println(num1,ok1) println(num2,ok2) } channel 底层实现 无缓冲 channel 与有缓存 channel 区别 channel VS mutex  channel 简介 🔗 Do not communicate by sharing memory; instead, share memory by communicating.
 不要通过共享内存来通信，而要通过通信来实现内存共享。这是 CSP（Communicating Sequential Processes）的思想，也是 Go 并发设计上的哲学。CSP 认为如果编程语言中把侧重点放在 processes 间的通信，那么并发编程会变得很简单，而 Go 中 channel 就是通信实体的实现，可以看作成一个协程间的消息队列。</description>
    </item>
    
    <item>
      <title>Golang 程序启动过程</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/golang/golang-%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Fri, 26 Nov 2021 17:10:12 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/golang/golang-%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</guid>
      <description>go run main.go 一个 Go 程序就启动了。然而这背后操作系统如何执行到 Go 代码的，Go 为了运行用户 main 函数，又做了什么？
 一 编译 🔗 go build main.go  我们写的 go 代码都是编译成可执行文件去机器上直接执行的，在 linux 平台上是 ELF 格式的可执行文件，linux 能直接执行这个文件。
 编译器：将 go 代码生成 .s 汇编代码，go 中使用的是 plan9 汇编 汇编起：将汇编代码转成机器代码，即目标程序 .o 文件 链接器：将多个 .o 文件合并链接得到最终可执行文件  graph LR 0(写代码)--go程序--&amp;gt; 1(编译器)--汇编代码--&amp;gt; 2(汇编器)--.o目标程序--&amp;gt;3(链接器)--可执行文件--&amp;gt;4(结束) 二 操作系统加载 🔗 ./main  经上述几个步骤生成可执行文件后，二进制文件在被操作系统加载起来运行时会经过如下几个阶段：
 从磁盘上把可执行程序读入内存； 创建进程和主线程； 为主线程分配栈空间； 把由用户在命令行输入的参数拷贝到主线程的栈； 把主线程放入操作系统的运行队列等待被调度执起来运行；  START_THREAD(elf_ex, regs, elf_entry, bprm-&amp;gt;p) 启动线程传入了 elf_entry 参数，这是程序的入口地址。
这个 elf_entry 被写在 elf 可执行文件的 header 中</description>
    </item>
    
    <item>
      <title>云服务器可以干什么系列:自建云盘</title>
      <link>https://he2121.github.io/xiaohe-blog/mixed/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E5%B9%B2%E4%BB%80%E4%B9%88%E7%B3%BB%E5%88%97-%E8%87%AA%E5%BB%BA%E4%BA%91%E7%9B%98/</link>
      <pubDate>Sun, 21 Nov 2021 20:39:11 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/mixed/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E5%B9%B2%E4%BB%80%E4%B9%88%E7%B3%BB%E5%88%97-%E8%87%AA%E5%BB%BA%E4%BA%91%E7%9B%98/</guid>
      <description>最近手痒买了一台 4 核 8 G 的阿里云服务器，一直空置也不是事，来发掘下它能干什么吧
 项目介绍 🔗直接放出今天的主角： cloudreve 体验下来，安装简单，功能也比较强大，有需求的同学可以试试。
安装过程 🔗 登陆服务器，安装 docker 以 docker 镜像 方式，部署服务  &amp;lt;PATH TO uploads&amp;gt;:上传目录，如/sharedfolders &amp;lt;PATH TO config&amp;gt;: 配置文件夹，如/dockercnf/cloudreve/config &amp;lt;PATH TO db&amp;gt;: 数据库文件夹，如/dockercnf/cloudreve/db &amp;lt;PATH TO avatar&amp;gt;: 头像文件夹，如/dockercnf/cloudreve/avatar 新建目录（/cloudreve）
在(/cloudreve)创建上述四个文件夹，如，
mkdir -p &amp;lt;PATH TO config&amp;gt; 创建配置文件vim &amp;lt;PATH TO config&amp;gt;/conf.ini（该配置文件针对SQLite数据库，如需使用MySQL等数据库，请参见 cloudreve官方文档）
# conf.ini [Database] DBFile = /cloudreve/db/cloudreve.db 启动cloudreve容器
docker run -d \  --name cloudreve \  -e PUID=1000 \ # optional -e PGID=1000 \ # optional -e TZ=&amp;#34;Asia/Shanghai&amp;#34; \ # optional -p 5212:5212 \  --restart=unless-stopped \  -v &amp;lt;PATH TO uploads&amp;gt;:/cloudreve/uploads \  -v &amp;lt;PATH TO config&amp;gt;:/cloudreve/config \  -v &amp;lt;PATH TO db&amp;gt;:/cloudreve/db \  -v &amp;lt;PATH TO avatar&amp;gt;:/cloudreve/avatar \  xavierniu/cloudreve  服务器开放所需端口（5212）</description>
    </item>
    
    <item>
      <title>Golang 协程与调度器原理</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/golang/golang%E5%8D%8F%E7%A8%8B%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 17 Nov 2021 14:30:00 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/golang/golang%E5%8D%8F%E7%A8%8B%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86/</guid>
      <description>思考从容器上该如何设置 GOMAXPROCS 大小引发，这个数字设置多少合理，其到底限制了什么，cpu 核数，系统线程数还是协程数？
 背景 🔗Go 语言可以说为并发而生。Go 从语言级别支持并发，通过轻量级协程 Goroutine 来实现程序并发运行，go关键字的强大与简洁是其它语言不可及的，接下来让我们一起来探索 Golang 中 Goroutine 与协程调度器设计的一些原理吧。
Go 协程 🔗概念 🔗进程: 操作系统分配系统资源（cpu 时间片，内存等）的最小单位
线程：轻量级进程，是操作系统调度的最小单位
协程：轻量级线程，协程的调度由程序控制
怎么理解 🔗进程，线程的两个最小单位如何理解？ 🔗在早期面向进程设计的计算机结构中，进程就是操作系统分配系统资源与操作系统调度的最小单位
但在现代的计算结构中，进程升级为线程的容器，多个线程共享一个进程内的系统资源，cpu 执行（调度）对象是线程
轻量级进程与轻量级线程如何理解 🔗轻量级进程：如下图各个进程拥有独立的虚拟内存空间，里面的资源包括 栈，代码，数据，堆&amp;hellip; 而线程拥有独立的栈，但是共享进程全部的资源。在 linux 的实现中，进程与线程的底层数据结构是一致的，只是同一进程下线程会共享资源。
轻量级线程：线程栈大小固定 8 M，协程栈：2 KB ，动态增长。一对线程里对应多个协程，可以减少线程的数量
协程相对线程有什么优势 🔗 轻量级 （MB vs KB） 切换代价低 （调度由程序控制，不需要进入内核空间。需要保存上下文一般少一些） 切换频率低，协程协作式调度，线程调度由操作系统控制，需要保证公平性，当线程数量一多，切换频率相对比较高  协程调度器 🔗在 Golang 中，goroutine 调度是由 Golang 运行时（runtime）负责的，不需要程序员编写代码时关注协程的调度。
GM 模型 🔗goroutine 的调度其实是一个生产者-消费者模型。
生产者：程序起 goroutine（G）
消费者：系统线程（M）去消费（执行）goroutine
自然的，在生产者与消费者中间还需要有一个队列来暂存没有消费过的 goroutine。在 Go 1.1 版本，用的就是这种模型。
GM 模型问题</description>
    </item>
    
    <item>
      <title>MESI 协议引发的一些思考</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/mesi%E5%8D%8F%E8%AE%AE%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</link>
      <pubDate>Wed, 17 Nov 2021 14:30:00 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/mesi%E5%8D%8F%E8%AE%AE%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</guid>
      <description>某个下午偶尔间看到了 MESI 缓存一致性协议，引出了我不少相关的疑惑，写下此文记录
 通过这篇文章你能了解到的知识 🔗 MESI 协议是什么，解决了什么问题 指令重排 是什么，解决了什么问题 内存屏障 是什么，解决了什么 MESI 与 并发同步的区别  MESI 缓存一致性协议 🔗MESI 产生的前提 🔗 多级缓存的出现 多核 CPU 的出现  总之为了计算机的性能，现代计算机都具备上述两点的设计，下图为不同存储的 IO 速度对比
MESI 解决的问题 🔗由于现在计算机都是多核 CPU 了，并且每一个 CPU 都有自己独立的缓存（如下图架构），这样就会有可能多个 cpu 操作同一份数据，导致各个 cpu 缓存中的同一份数据值不一致的情况。
MESI 的具体设计 🔗MESI：由缓存行（缓存中操作的基本单位，类似于磁盘的页）的四个状态首字母组成:
 Modified（修改）：这一行数据修改过了，与内存中的数据不一致了，这意味着如果其它 cpu 中的缓存具有这行数据，其状态要修改成 invalid Exclusive（独占）：只有一个 cache 读了这个数据行，并且没有修改过 Shared（共享）：有多个 cpu 的cahe 读了这个数据行，没有被修改过 Invalid（无效）：该缓存这一行的数据无效  状态流转 🔗缓存行的状态流转如下图，通过对各个缓存行状态位的控制，达到了多核 cpu 缓存中数据一致的目的
一个例子
 现在有两个 cpu，假定其缓存都为空，内存中有一个 x = 0 的数据 cpu1 通过 bus 从内存中读取 x， 该缓存行状态设置为 E cpu2 通过 bus 从内存中读取 x，cpu 1 嗅探到地址冲突，两个 cpu 中 x 所在缓存行状态位设置为 S cpu1 需要修改其缓存中 x 的值，设置其 x 所在缓存行状态为 M，通知 cpu2 把 x 所在缓存行状态位设置为 I，再修改缓存中 x 的值  **模拟网站：**https://www.</description>
    </item>
    
    <item>
      <title>普通人的理财-阶段总结一</title>
      <link>https://he2121.github.io/xiaohe-blog/mixed/%E6%99%AE%E9%80%9A%E4%BA%BA%E7%9A%84%E7%90%86%E8%B4%A2-%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E4%B8%80/</link>
      <pubDate>Sat, 13 Nov 2021 00:08:32 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/mixed/%E6%99%AE%E9%80%9A%E4%BA%BA%E7%9A%84%E7%90%86%E8%B4%A2-%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93%E4%B8%80/</guid>
      <description>起因 🔗两天没写博客了，但想要坚持下去这个习惯。技术文章太费头发了，因此起一个新系列，记录下自己的理财吧（水一下）。
回顾 🔗启蒙 🔗最初的相遇要追溯到下面那张图
关键词: &amp;ldquo;2018-02-09&amp;quot;，&amp;ldquo;10.00&amp;rdquo;
当时的我对理财并没有概念，可能只是偶尔听说这个东西能赚钱，就入手了十块，最终我以10.40 的价格卖出，净赚 0.4。可我认为这并不是我的理财起点，因为当时我还只是个学生，生活费还不够呢，哪有闲钱买这个，事实也证明接下来的一年，我再也没有关注和操作基金了。
起点 🔗直到一年后，我的理财之旅才真正开始。
关键词：&amp;quot;2019-02-26&amp;quot;， “100.00”
背景：
看上面大盘，经过 2018 年的大跌后，2019 年初开始强势反弹了。当然当时我不可能了解这个，当时我开始操作基金是因为：
 已经涨过一轮了，行情火热，消息已经传递到我这普通人耳边了 当时在知乎看了许多指数基金的帖子，自己也对这些有兴趣，感觉稳赚不赔 当时已就读研究生了，有一些闲钱以及在可预见的未来都会攒下一些钱（也就千数量级吧）  从此正式入坑，一开始都是买一些指数基金（中证 500，沪深 300，上证 50 &amp;hellip; ）。其实都是小打小闹，一两千还买来卖去。
随着 2019 年的行情越来越好，我也赚了一些，并且在 2019 年 4 月，当时由于自己要用钱，卖出一大部分基金，歪打正着躲过了一次回调。后面胆子也就大了起来，一直加仓，由于自己对互联网比较看好，也不只买指数基金了，开始尝试一些互联网，信息之类的基金。
到 2019 年末，我已经在基金中投入了一万左右了，并且持有了十几只基（各种类型都试下水）。
冒险 🔗时间来到了 2020 年春节，此刻我已经可以算得上一个资深基民了，每天都得关注一下基金。然而春节假期中有一件意想不到的大事发生了 - 新冠。
节后开盘指数就开始猛跌，随后我就把我仅剩的几千全部加仓，但还是跌，很快我的 2019 年利润没了，并且开始亏损了。
当时三四月份疫情已经控制得不错了，我的判断是疫情很快就会结束，必须加仓！我问家人借了一万加仓。当时我比较看好新能源，并且由于眼红之前没上大涨半导体的车，这次加仓主要这两个品类，当然由于跌得太狠，我没敢一次性加仓进去，一直慢慢加。
很幸运这次我赌对了（虽然疫情没有结束，但走势明显是一波小牛市），最高峰时期发生在 2021 春节，当时 2 万多点的本金，我已经赚了一万多了，新能源盈利已经接近100%了！
而不幸的是，当时的胜利已经让我失去理智，骄傲自大了。冒险成为了我理财的最大障碍，我现在的交易也很难克服自己内心的冲动。而当时的我已经在基金中得不到满足，我开始盯上了 A 股。
癫狂 🔗2021 春节后 大盘也经历了一些回调，我也一如既往的加仓，我加仓太早，这期间吐回不少盈利。
但这期间，由于我刚开始工作一段时间和一些其它原因要用钱。没能坚持到涨回去，我就把基金基本全卖了。其实当时股票里也有一些钱，但我已经不想再操作基金了，准备以后只操作股票。
下图就是我基金的最终战果了，有遗憾（新能源从最多 90% 的盈利，到卖出只有 40% 多的盈利），但其实成绩也还算可以了。
之前的操作如果还能勉强说正常，后面操作就比较癫狂了。
 之前看好的新能源，现在由于价格比较高，我不敢入手 听信各种大 v 的价值投资，白马蓝筹股吹嘘 由于买的白马蓝筹不断跌，承受不了这么多的亏损，开始京东金条加仓，幻想很快能涨回来  现在已不堪回首那个阶段了，今年的 4，5，6，7，8 月份应该都处于这种情况，每月都借，每月都还。</description>
    </item>
    
    <item>
      <title>MySQL binlog 设计</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/mysql/mysqlbinlog%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Wed, 10 Nov 2021 18:33:24 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/mysql/mysqlbinlog%E8%AE%BE%E8%AE%A1/</guid>
      <description>通过这篇文章你能了解到的知识 🔗 binlog 是什么 binlog 的作用 binlog 的三种类型，以及各自优缺点 binlog 文件的结构与内容  binlog 是什么 🔗Binary Log，顾名思义是一种二进制格式的日志。具体来说，binlog 日志是一组包含了对 MySQL server 实例进行数据修改（update/delete/insert/...）信息的文件。
binlog 作用 🔗 用于复制，如主从复制 数据恢复  binlog 类型 🔗 基于语句 (Statement-based)的日志记录 (SBL): 事件包含产生数据变化的SQL语句。 基于行 (Row-based) 的日志记录(RBL): 描述单个行的变化 混合 (Mixed)：上述两者结合使用, 以 SBL 为主，特殊情况下切换到 RBL  binlog 为什么会有这三种类型？
一开始只有 statement-based，但 statement-based 存在不少问题，后面才有的 row 与 mixed。
SBL 优点 🔗 产生的日志文件少， io 次数少  SBL 缺点 🔗  在一些不安全的语句上，主从复制做不到数据一致，比如
  含有系统函数的语句，可能会在副本上返回不同的值，如 RAND(), USER(),UUID(), SYSDATE() .</description>
    </item>
    
    <item>
      <title>2021度博客每周回顾</title>
      <link>https://he2121.github.io/xiaohe-blog/mixed/2021%E5%BA%A6%E5%8D%9A%E5%AE%A2%E6%AF%8F%E5%91%A8%E5%9B%9E%E9%A1%BE/</link>
      <pubDate>Wed, 10 Nov 2021 14:08:32 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/mixed/2021%E5%BA%A6%E5%8D%9A%E5%AE%A2%E6%AF%8F%E5%91%A8%E5%9B%9E%E9%A1%BE/</guid>
      <description>每周至少三篇博客，用这个监督下自己
11.8 - 11.14 🔗 使用 Hugo 与 GitHub Pages 快速建站 Golang 常用日志库介绍 Convert资源集合 普通人的理财-阶段总结一  11.15-11.21 🔗 MySQL binlog 设计 MESI 缓存一致性引发的一些思考 云服务器可以干什么-系列一（自建云盘）  11.22-11.28 🔗 Golang 协程与调度器原理 Golang 程序启动过程  11.29 - 12.05 🔗 Golang channel Golang linkname  12.06 - 12.12 🔗 prometheus-01 prometheus-02 vim 常见操作  12.13 - 12.19 🔗 6.824 lab1 vscode 远程开发  12.20 - 12.26 🔗 Golang 汇编介绍 分布式链路追踪 jaeger  12.27 - 1.</description>
    </item>
    
    <item>
      <title>Convert资源集合</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/convert%E8%B5%84%E6%BA%90%E9%9B%86%E5%90%88/</link>
      <pubDate>Wed, 10 Nov 2021 00:38:28 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/convert%E8%B5%84%E6%BA%90%E9%9B%86%E5%90%88/</guid>
      <description>json2go 🔗 https://mholt.github.io/json-to-go/  sql2go 🔗 https://sql2go.ricestdiotech.com/  curl2go 🔗 https://mholt.github.io/curl-to-go/  curl2all 🔗 https://curlconverter.com/  yaml2go 🔗 https://yaml2go.prasadg.dev/  toml2go 🔗 https://xuri.me/toml-to-go/  数据转换大集合(json、xml、html、yaml、toml、csv、xlsx、png、pdf&amp;hellip;) 🔗 https://www.convertsimple.com/  sql2es 🔗 https://sqltoelasticsearch.azurewebsites.net/  time convert 🔗 https://www.epochconverter.com/  base 64 encode/decode 🔗 https://www.base64decode.org/  欢迎评论补充 🔗- ...  </description>
    </item>
    
    <item>
      <title>Golang 常用日志库介绍</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/golang/golang%E6%97%A5%E5%BF%97%E5%BA%93%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Tue, 09 Nov 2021 14:30:12 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/golang/golang%E6%97%A5%E5%BF%97%E5%BA%93%E4%BB%8B%E7%BB%8D/</guid>
      <description>前言 🔗为什么需要日志 🔗 调试开发 程序运行日志 用户行为日志  不同的目的决定了日志输出的格式、频率。作为开发人员，调试开发阶段打印日志目的是输出尽可能全的信息（如上下文，变量值&amp;hellip;），辅助开发测试，因此日志格式要易读，打印频率要高。而在程序运行时，日志格式倾向于结构化（便于分析与搜索），而且为了性能和聚焦于关键信息（如error ），打印频率更偏低。
Go 标准库 Log 🔗使用 🔗我们常使用 Go log 以下三组函数：
 Print/Printf/Println : 打印日志信息  Panic/Panicf/Panicln : 打印日志信息后，以拼装好的字符串为参数调用 Panic  Fatal/Fatalf/Fatalln : 打印日志信息后，os.Exit(1) 退出程序  带 f 后缀的是格式化输出，ln 后缀增加换行符，不过在打印日志场景中会自动增加一个换行符，这里 ln 后缀差别不大。Panic 与 Fatal 的区别在于 Panic 可以被捕获。
示例如下:
package main import &amp;#34;log&amp;#34; func main() { log.Println(&amp;#34;日志信息1&amp;#34;) log.Print(&amp;#34;日志信息2&amp;#34;) log.Panicln(&amp;#34;日志信息3&amp;#34;) log.Fatalln(&amp;#34;日志信息4&amp;#34;) // 运行不到 } 2021/11/09 15:41:34 日志信息1 2021/11/09 15:41:34 日志信息2 2021/11/09 15:41:34 日志信息3 panic: 日志信息3 goroutine 1 [running]: log.</description>
    </item>
    
    <item>
      <title>使用 Hugo 与 GitHub Pages 快速建站</title>
      <link>https://he2121.github.io/xiaohe-blog/site/%E4%BD%BF%E7%94%A8hugo%E4%B8%8Egithub-pages%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99/</link>
      <pubDate>Mon, 08 Nov 2021 20:39:11 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/site/%E4%BD%BF%E7%94%A8hugo%E4%B8%8Egithub-pages%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99/</guid>
      <description>前言 🔗作为一名程序员，并且是一名有追求的程序员，技术影响力 对我们不可或缺。今天介绍一下我是如何利用 Hugo 与 GitHub Pages 快速搭建个人内容输出平台。
Hugo 与 GitHub Pages 简介 🔗Hugo: 世界上最快的网站建设框架，将 Markdown 文件生成 HTML 静态页面。
GitHub Pages GitHub 提供的静态网页托管服务，不需要额外的服务器来部署你的博客系统了。
搭建过程 🔗 安装 Hugo  Mac 直接使用以下命令二进制安装
brew install hugo  GitHub 创建一个仓库，如 xiaohe-blog，并且 git clone 到本地
  使用 Hugo 初始化 Clone 下来的仓库
  hugo new site xiaohe-blog --force 生成文件目录应该如下:
├── archetypes // 文章默认模版 │ └── default.md ├── config.toml // 配置文件 ├── content // Markdown 文件 ├── data // ├── layouts // html 文件 ├── static // 图片, CSS, JS.</description>
    </item>
    
    <item>
      <title>提升技术影响力</title>
      <link>https://he2121.github.io/xiaohe-blog/mixed/%E6%8F%90%E5%8D%87%E6%8A%80%E6%9C%AF%E5%BD%B1%E5%93%8D%E5%8A%9B%E8%AE%A1%E5%88%92/</link>
      <pubDate>Mon, 08 Nov 2021 20:39:11 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/mixed/%E6%8F%90%E5%8D%87%E6%8A%80%E6%9C%AF%E5%BD%B1%E5%93%8D%E5%8A%9B%E8%AE%A1%E5%88%92/</guid>
      <description>计划 🔗 每周至少三篇博客 持续至少两年 更新到各大平台  平台 🔗 自己的博客 CSDN 知乎 掘金 思否 博客园 微信公共号  发布帖子热度 🔗 知乎 CSDN 掘金   todo 🔗 vscode/GoLand 一键发布帖子插件 vscode/GoLand markdown图床支持(类似 typora + upic)  </description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://he2121.github.io/xiaohe-blog/about/</link>
      <pubDate>Sun, 10 Oct 2021 11:25:11 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/about/</guid>
      <description>2021度博客每周回顾
2022度博客每周回顾
2022读书计划</description>
    </item>
    
    <item>
      <title>Go 反射解析与实战</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/golang/go-%E5%8F%8D%E5%B0%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/</link>
      <pubDate>Mon, 30 Aug 2021 17:10:12 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/golang/go-%E5%8F%8D%E5%B0%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/</guid>
      <description>前言 🔗日常写业务时，我们很少会用到反射，导致大部分人对 go 的反射还比较陌生。 虽然并不推荐在业务代码中写反射代码，但是了解它，能够让我们更好的去理解许多框架的逻辑，以及能够让自己具备有初步实现一个通用第三方 SDK 的能力。
什么是反射 🔗 在计算机学中，反射是指计算机程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。
 来自维基百科
在 Golang 中，其实就是编译时是 interface{}，不知道其具体的类型，要在运行中反射获取类型、更新检查他们的值、
执行它们的方法，
反射能够干什么 🔗反射是元编程的一个关键策略
 java spring golang json 序列化与反序列化 go orm 框架 &amp;hellip;  反射的缺点 🔗 性能 可读性 go 作为静态语言，编译时能检查出不少问题，但反射跳过这检查，可能在运行中 panic  Golang 反射解析 🔗要搞清楚反射，得先简要了解一下 interface
Interface 🔗定义 🔗接口有两种定义：
  eface: 空接口定义, 包含具体类型与数据
  iface: 非空接口定义（实现了方法的接口），
  // 位于 src/runtime/runtime2.go type eface struct { _type *_type	// 具体的类型 	data unsafe.Pointer	// 数据 } type iface struct { tab *itab	// 指向itab 的指针 	data unsafe.</description>
    </item>
    
    <item>
      <title>前缀和相关算法题</title>
      <link>https://he2121.github.io/xiaohe-blog/algorithm/%E5%89%8D%E7%BC%80%E5%92%8C%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/</link>
      <pubDate>Fri, 26 Feb 2021 17:10:12 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/algorithm/%E5%89%8D%E7%BC%80%E5%92%8C%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://he2121.github.io/xiaohe-blog/mixed/%E6%83%B3%E6%B3%95%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/mixed/%E6%83%B3%E6%B3%95%E8%AE%B0%E5%BD%95/</guid>
      <description>·这里记录一些突然冒出的想法
常规技术文章 🔗 Golang 的程序启动过程， m0，g0，sysmon？ 从 golang 启动源代码出发: 读懂一些汇编代码需要掌握的一些知识 Golang 协作式调度与抢占式调度 Golang channel 原理介绍 介绍 MySQL 的 redo，undo log 内存分配器 malloc Git 实战操作记录 Golang 中的 linkname Test suite 介绍 打点 prometheus普罗米修斯 介绍 分布式服务追踪 jaeger 介绍  造轮子系列 🔗 手写 go-redis 系列 MIT-6.824 Lab 教程系列 实现一个 go-rpc  项目 🔗  vscode/jetbrain markdown image 插件
  vscode/jetbrain 创造者中心
  网页 Comment 社区
 diigo    互联网创业组队</description>
    </item>
    
    <item>
      <title></title>
      <link>https://he2121.github.io/xiaohe-blog/mixed/%E6%B5%81%E7%A8%8B%E5%9B%BE%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/mixed/%E6%B5%81%E7%A8%8B%E5%9B%BE%E4%BB%A3%E7%A0%81/</guid>
      <description>channel 🔗graph LR 1(channel) --&amp;gt; 2(向 channel 发送消息) 1 --&amp;gt; 3(接受消息) 1 --&amp;gt; 4(关闭channel) 2 -- full channel--&amp;gt; 5(阻塞) 2 --closed channel--&amp;gt; 6(panic) 3 --empty channel--&amp;gt;5 3 --closed channel--&amp;gt; 7(读到零值) 4 --closed/nil channel--&amp;gt; 6  graph TB 1(向 channel 发送消息) --&amp;gt; 2{channel 是否 nil} --否--&amp;gt; 4{channel 是否 closed}--否--&amp;gt; 6{recvq 队列是否存在值}--否--&amp;gt;8{buf 是否未满} --否--&amp;gt; 10(阻塞协程,并放到 sendq 队列中) 2 --是--&amp;gt; 3(阻塞) 4 --是--&amp;gt; 5(panic) 6 --是--&amp;gt; 7(队首出队,消息直接发送至该 goroutine 中) 8--是--&amp;gt; 9(消息拷贝到 buf sendx位置中,等待唤醒) graph TB 1(向channel接受消息) --&amp;gt; 2{channel是否nil} --否--&amp;gt; 4{channel是否closed &amp;amp;&amp;amp; buf中元素为空}--否--&amp;gt; 6{sendq队列是否存在值}--否--&amp;gt;8{buf 是否为空} --是--&amp;gt; 10(阻塞协程,并放到recvq队列中) 2 --是--&amp;gt; 3(阻塞) 4 --是--&amp;gt; 5(返回零值) 6 --是--&amp;gt; 7(sendq队首出队) --无缓冲channel--&amp;gt; 11(将出队goroutine发送的消息拷贝到返回数据) 7 --缓冲channel--&amp;gt; 12(将buf队首消息copy到返回数据) --&amp;gt; 13(再将sendq出队的goroutine发送消息拷贝到buf) 8--否--&amp;gt; 9(将 buf 队首消息 copy 到返回数据) </description>
    </item>
    
  </channel>
</rss>
