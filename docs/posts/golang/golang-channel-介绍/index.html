<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <title>Golang channel 原理介绍 | 小贺的博客</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="问题 🔗 从关闭的 channel 读取数据，如以下情况输出什么。如果是发送数据，再关闭一次 channel的操作呢？怎么判断 channel 的是否关闭  func main() { ch := make(chan int,2) ch &lt;- 1 close(ch) num1, ok1 := &lt;- ch num2,ok2 := &lt;- ch println(num1,ok1) println(num2,ok2) } channel 底层实现 无缓冲 channel 与有缓存 channel 区别 channel VS mutex  channel 简介 🔗 Do not communicate by sharing memory; instead, share memory by communicating.
 不要通过共享内存来通信，而要通过通信来实现内存共享。这是 CSP（Communicating Sequential Processes）的思想，也是 Go 并发设计上的哲学。CSP 认为如果编程语言中把侧重点放在 processes 间的通信，那么并发编程会变得很简单，而 Go 中 channel 就是通信实体的实现，可以看作成一个协程间的消息队列。">
<meta name="generator" content="Hugo 0.89.2" />


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/xiaohe-blog/css/style.css">



<link rel="shortcut icon" href="/xiaohe-blog/images/favicon.ico" type="image/x-icon" />

 
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-FY1WNXTY3L', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







  </head>

  <body>
    <nav class="navigation">
	
		<a href="/xiaohe-blog/"> <span class="arrow">←</span>首页</a>
	
	<a href="/xiaohe-blog/posts">归档</a>
	<a href="/xiaohe-blog/tags">标签</a>
	<a href="/xiaohe-blog/about">关于</a>

	
		<a href="/xiaohe-blog/%e7%ae%97%e6%b3%95">算法</a>
	
		<a href="/xiaohe-blog/%e6%9d%82%e8%b0%88">杂谈</a>
	

	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">Golang channel 原理介绍</h1>

    <div class="tip">
      <div>2021年11月29日</div>
        <span class="split">
          ·
        </span>
        <span>
          864字
        </span>
        <span class="split">
          ·
        </span>
        <span>
          5分钟 读完
        </span>
        <div class="views">
          <span class="views">
              <img src="https://visitor-badge.glitch.me/badge?page_id=https%3a%2f%2fhe2121.github.io%2fxiaohe-blog%2fposts%2fgolang%2fgolang-channel-%25E4%25BB%258B%25E7%25BB%258D%2f" alt="Views"/>
          </span>
      </div>
    </div>

    
    


    <div class="content">
      <h3 id="问题">问题 <a href="#%e9%97%ae%e9%a2%98" class="anchor">🔗</a></h3><ol>
<li>从关闭的 channel 读取数据，如以下情况输出什么。如果是发送数据，再关闭一次 channel的操作呢？怎么判断 channel 的是否关闭</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>,<span style="color:#ae81ff">2</span>)
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">1</span>
	close(<span style="color:#a6e22e">ch</span>)
	<span style="color:#a6e22e">num1</span>, <span style="color:#a6e22e">ok1</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch</span>
	<span style="color:#a6e22e">num2</span>,<span style="color:#a6e22e">ok2</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch</span>
	println(<span style="color:#a6e22e">num1</span>,<span style="color:#a6e22e">ok1</span>)
	println(<span style="color:#a6e22e">num2</span>,<span style="color:#a6e22e">ok2</span>)
}
</code></pre></div><ol start="2">
<li>channel 底层实现</li>
<li>无缓冲 channel 与有缓存 channel 区别</li>
<li>channel VS mutex</li>
</ol>
<h2 id="channel-简介">channel 简介 <a href="#channel-%e7%ae%80%e4%bb%8b" class="anchor">🔗</a></h2><blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<p>不要通过共享内存来通信，而要通过通信来实现内存共享。这是 CSP（Communicating Sequential Processes）的思想，也是 Go 并发设计上的哲学。CSP 认为如果编程语言中把侧重点放在 processes 间的通信，那么并发编程会变得很简单，而 Go 中 channel 就是通信实体的实现，可以看作成一个协程间的消息队列。</p>
<h2 id="channel-使用">channel 使用 <a href="#channel-%e4%bd%bf%e7%94%a8" class="anchor">🔗</a></h2><p>对 channel 的操作有四种：</p>
<ul>
<li>创建 channel：<code>ch := make(chan int)</code> <code>ch:=make(chan string, 10) </code></li>
<li>向 channel 发送消息: <code>ch &lt;- num</code></li>
<li>从 channel 接受消息: <code>num &lt;- ch</code>, <code>num, ok := &lt;- ch</code></li>
<li>关闭 channel: <code>close(ch)</code>
一些对 channel 操作可能出现的一些边界条件情况如下图所示，其中 full channel 与 empty channel 在无缓冲和有缓冲 channel 下e的概念稍有不同，在下文中解释</li>
</ul>
<p><p class="markdown-image">
  <img src="http://ganghuan.oss-cn-shenzhen.aliyuncs.com/img/mermaid-diagram-20211130225330-2021-11-30.png" alt="mermaid-diagram-20211130225330"  />
</p></p>
<h2 id="channel-实现">channel 实现 <a href="#channel-%e5%ae%9e%e7%8e%b0" class="anchor">🔗</a></h2><h3 id="数据结构">数据结构 <a href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" class="anchor">🔗</a></h3><p>channel 的底层数据结构如下代码所示，个人认为主要由<strong>一个 buf 数组 + 2 个 goroutine 链表</strong>组成</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// src/runtime/chan.go
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">hchan</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">qcount</span>   <span style="color:#66d9ef">uint</span>           <span style="color:#75715e">// chan 中元素个数
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">dataqsiz</span> <span style="color:#66d9ef">uint</span>           <span style="color:#75715e">// chan 底层循环队列的长度
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">buf</span>      <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> <span style="color:#75715e">// 指向 循环队列的指针
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">elemsize</span> <span style="color:#66d9ef">uint16</span>					<span style="color:#75715e">// chan 中元素大小
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">closed</span>   <span style="color:#66d9ef">uint32</span>					<span style="color:#75715e">// 是否关闭的状态位
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">elemtype</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span> 				<span style="color:#75715e">// 元素类型
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sendx</span>    <span style="color:#66d9ef">uint</span>   				<span style="color:#75715e">// 已发送元素在循环队列中的索引
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">recvx</span>    <span style="color:#66d9ef">uint</span>   				<span style="color:#75715e">// 已接受元素在循环队列中的索引
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">recvq</span>    <span style="color:#a6e22e">waitq</span>  				<span style="color:#75715e">// 等待接受数据的 goroutine 队列
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sendq</span>    <span style="color:#a6e22e">waitq</span>  				<span style="color:#75715e">// 等待发送数据的 goroutine 列队
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">lock</span> <span style="color:#a6e22e">mutex</span>	<span style="color:#75715e">// 保护上述字段
</span><span style="color:#75715e"></span>}

</code></pre></div><ul>
<li><code>buf</code>: channel 流动的缓冲区，实际上是一个指向循环队列的指针，数据有无缓冲的 channel 的区别在这。无缓冲的 channel 即这个 buf 在初始化时没有分配内存。</li>
<li><code>recvq</code> 与 <code>sendq</code>: 阻塞的 goroutine 链表，分别是等待接受和等待发送数据的 goroutine 链表</li>
<li>其它字段基本是描述 buf 状态的：如 buf 容量(<code>dataqsiz</code>)，buf 具有的元素个数(<code>qcount</code>)，buf 中一个元素所占内存大小（<code>elemsize</code>），<code>sendx</code> 与 <code>recvx</code>描述 buf 循环数组中可向channel发送消息与接受channel 中消息的索引位置 &hellip;</li>
</ul>
<p>附上一个 channel 结构的网图供参考</p>
<p><p class="markdown-image">
  <img src="https://user-images.githubusercontent.com/7698088/61179068-806ee080-a62d-11e9-818c-16af42025b1b.png" alt="深度解密Go语言之channel - Stefno - 博客园"  />
</p></p>
<h3 id="向-channel-发送消息">向 channel 发送消息 <a href="#%e5%90%91-channel-%e5%8f%91%e9%80%81%e6%b6%88%e6%81%af" class="anchor">🔗</a></h3><ul>
<li><code>ch &lt;- num</code></li>
</ul>
<p>一般的向 channel 发送消息流程如下图:</p>
<p><p class="markdown-image">
  <img src="http://ganghuan.oss-cn-shenzhen.aliyuncs.com/img/mermaid-diagram-20211130230713-2021-11-30.png" alt="mermaid-diagram-20211130230713"  />
</p></p>
<blockquote>
<p>当然实际代码稍微复杂一些：在 channel 与 <code>select</code>,<code>case</code> 一起使用时，case 语句需要即时收到返回值，不能阻塞等待。因此需要一个非阻塞的模式，在 channel 为 full 时，不等待直接返回结果。</p>
</blockquote>
<p>直接上代码，实现起来也比较简单，基本是入队出队操作，有兴趣的可以看一下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// src/runtime/chan.go
</span><span style="color:#75715e"></span><span style="color:#a6e22e">ep</span> <span style="color:#a6e22e">是发送数据的指针</span>, <span style="color:#a6e22e">block</span> <span style="color:#a6e22e">表示是否可以把当前协程阻塞</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">放到</span> <span style="color:#a6e22e">sendq</span> <span style="color:#a6e22e">队列</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">同步等待结果</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">一般都是true</span><span style="color:#960050;background-color:#1e0010">。</span><span style="color:#a6e22e">只有</span> <span style="color:#66d9ef">select</span> <span style="color:#a6e22e">时</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">不阻塞协程</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">直接返回</span><span style="color:#960050;background-color:#1e0010">。</span><span style="color:#a6e22e">返回值表示是否成功发送数据</span>
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">chansend</span>(<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">hchan</span>, <span style="color:#a6e22e">ep</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>, <span style="color:#a6e22e">block</span> <span style="color:#66d9ef">bool</span>, <span style="color:#a6e22e">callerpc</span> <span style="color:#66d9ef">uintptr</span>) <span style="color:#66d9ef">bool</span> {
  <span style="color:#75715e">// channel 为 nil
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
    <span style="color:#75715e">// select 非阻塞，直接返回 false
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">block</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
		}
    <span style="color:#75715e">// 阻塞协程
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">gopark</span>(<span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">waitReasonChanSendNilChan</span>, <span style="color:#a6e22e">traceEvGoStop</span>, <span style="color:#ae81ff">2</span>)
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;unreachable&#34;</span>)
	}
  <span style="color:#75715e">// 省略一些...
</span><span style="color:#75715e"></span>  
  <span style="color:#75715e">// select 非阻塞,如果 channel 没有关闭, channel 为 full：有缓冲（buf 满了），无缓冲（recvq 为空）
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">block</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">closed</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">full</span>(<span style="color:#a6e22e">c</span>) {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
	}
  <span style="color:#75715e">// ... 省略了一些...
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 如果 channel 关闭了，panic
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">closed</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>)
		panic(<span style="color:#a6e22e">plainError</span>(<span style="color:#e6db74">&#34;send on closed channel&#34;</span>))
	}
  <span style="color:#75715e">// 若 receq 不为空，把 receq 队列取一个 goroutine，直接把其要发送的消息ep发到取到的 goroutine 中。存在两种情况
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 1. 这是无缓冲 channel发送数据的过程，
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 2. 有缓冲 channel receq 不为空，则说明其 buf 数组为空，
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvq</span>.<span style="color:#a6e22e">dequeue</span>(); <span style="color:#a6e22e">sg</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">send</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">sg</span>, <span style="color:#a6e22e">ep</span>, <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>) }, <span style="color:#ae81ff">3</span>)
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
	}
  <span style="color:#75715e">// 有缓冲 channel，且其 buff 数组还没满，把 ep 数据放到 buf 中
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">qcount</span> &lt; <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">dataqsiz</span> {
		<span style="color:#75715e">// 返回sendx 指向的地址
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">qp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">chanbuf</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">sendx</span>)
    <span style="color:#75715e">// 把 ep 中的消息 copy 到 buf 中
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">typedmemmove</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">elemtype</span>, <span style="color:#a6e22e">qp</span>, <span style="color:#a6e22e">ep</span>)
    <span style="color:#75715e">// sendx count... 的修改
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">sendx</span><span style="color:#f92672">++</span>
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">sendx</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">dataqsiz</span> {
			<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">sendx</span> = <span style="color:#ae81ff">0</span>
		}
		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">qcount</span><span style="color:#f92672">++</span>
		<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>)
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
	}
  <span style="color:#75715e">// 以上都不成功，阻塞当前协程
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">sendq</span>.<span style="color:#a6e22e">enqueue</span>(<span style="color:#a6e22e">mysg</span>)	<span style="color:#75715e">// 当前协程入队 sendq
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">gopark</span>(<span style="color:#a6e22e">chanparkcommit</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>), <span style="color:#a6e22e">waitReasonChanSend</span>, <span style="color:#a6e22e">traceEvGoBlockSend</span>, <span style="color:#ae81ff">2</span>)	<span style="color:#75715e">// 阻塞
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}
</code></pre></div><p>这里解释下 full/empty channel。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Channel 类型</th>
<th style="text-align:center">Full</th>
<th style="text-align:center">Empty</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">无缓冲</td>
<td style="text-align:center">reveq 队列为空：没有等待接受消息的协程</td>
<td style="text-align:center">sendq 队列为空：没有等待发送消息的协程</td>
</tr>
<tr>
<td style="text-align:center">有缓冲</td>
<td style="text-align:center">buf 数组已满</td>
<td style="text-align:center">buf 数组为空</td>
</tr>
</tbody>
</table>
<p><strong>总结</strong></p>
<ul>
<li>无缓冲 channel 发送消息是<strong>直接将消息从发送者的栈拷贝到接收者的栈</strong></li>
<li>有缓冲 channel发送消息是<strong>将消息拷贝到 channel buf 中</strong></li>
</ul>
<h3 id="从-channel-中接受消息">从 channel 中接受消息 <a href="#%e4%bb%8e-channel-%e4%b8%ad%e6%8e%a5%e5%8f%97%e6%b6%88%e6%81%af" class="anchor">🔗</a></h3><ul>
<li><code>num &lt;- ch</code></li>
<li><code>num,ok &lt;- ch</code>
第二个布尔返回值代表着这次通信是否成功，只有当 channel 是关闭状态并且 channel 是 Empty 才返回 false，也就是说即使channel 已经关闭，但如果其还有消息在 buf 中，返回的布尔值是 true。</li>
</ul>
<p>向 channel 接受消息的流程与发送消息类似，整体如下图所示：</p>
<blockquote>
<p>此示意图也省略了考虑不阻塞的场景（与<code>select</code> ,<code>case</code>）</p>
</blockquote>
<p><p class="markdown-image">
  <img src="http://ganghuan.oss-cn-shenzhen.aliyuncs.com/img/image-20211130231739724-2021-11-30.png" alt="image-20211130231739724"  />
</p></p>
<p>代码详情如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// ep: 接受数据，block：是否阻塞式接受, selected: 是否有返回值(select 语句 并且 channel empty 无返回值) received: 此返回值是否是正常由发送者发送过来的数据
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">chanrecv</span>(<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">hchan</span>, <span style="color:#a6e22e">ep</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>, <span style="color:#a6e22e">block</span> <span style="color:#66d9ef">bool</span>) (<span style="color:#a6e22e">selected</span>, <span style="color:#a6e22e">received</span> <span style="color:#66d9ef">bool</span>) {
  <span style="color:#75715e">// channel 为空
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
    <span style="color:#75715e">// 非阻塞直接返回 false false
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">block</span> {
			<span style="color:#66d9ef">return</span>
		}
    <span style="color:#75715e">// 阻塞协程
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">gopark</span>(<span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">waitReasonChanReceiveNilChan</span>, <span style="color:#a6e22e">traceEvGoStop</span>, <span style="color:#ae81ff">2</span>)
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;unreachable&#34;</span>)
	}

	<span style="color:#75715e">// 非阻塞快速失败
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">block</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">empty</span>(<span style="color:#a6e22e">c</span>) {
		<span style="color:#75715e">// channel 没有关闭，返回 false,false
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">closed</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
			<span style="color:#66d9ef">return</span>
		}
    <span style="color:#75715e">// channel 已经关闭, 需要返回零值，因此返回:true，false
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">empty</span>(<span style="color:#a6e22e">c</span>) {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ep</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
				<span style="color:#a6e22e">typedmemclr</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">elemtype</span>, <span style="color:#a6e22e">ep</span>)
			}
			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>
		}
	}
	<span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 得操作 buf 或者 sendq 队列了，并发需要加锁
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>)

  <span style="color:#75715e">// 如果 channel 已经关闭, 并且 buf 为空，返回零值
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">closed</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">qcount</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ep</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#a6e22e">typedmemclr</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">elemtype</span>, <span style="color:#a6e22e">ep</span>)
		}
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>
	}

  <span style="color:#75715e">// 发送队列不为空, 有两种情况sendq 不为空 
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 1. 无缓冲 channel，直接将队首的消息 copy 到 ep 指向的数据中
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 2. 有缓冲 channel，但是其 buf 已满。其中操作需要把 buf 队首数据 copy 到 ep 指向的数据， sendq 队首出队，将其发送的消息copy 到 buf 中
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">sendq</span>.<span style="color:#a6e22e">dequeue</span>(); <span style="color:#a6e22e">sg</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">recv</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">sg</span>, <span style="color:#a6e22e">ep</span>, <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>) }, <span style="color:#ae81ff">3</span>)
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">true</span>
	}
 
	<span style="color:#75715e">// buf 不为空，将 buf 队首数据 copy 到 ep 
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">qcount</span> &gt; <span style="color:#ae81ff">0</span> {
		<span style="color:#75715e">// Receive directly from queue
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">qp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">chanbuf</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvx</span>)
		<span style="color:#75715e">// ....
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ep</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#a6e22e">typedmemmove</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">elemtype</span>, <span style="color:#a6e22e">ep</span>, <span style="color:#a6e22e">qp</span>)
		}
		<span style="color:#a6e22e">typedmemclr</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">elemtype</span>, <span style="color:#a6e22e">qp</span>)
		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvx</span><span style="color:#f92672">++</span>
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvx</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">dataqsiz</span> {
			<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvx</span> = <span style="color:#ae81ff">0</span>
		}
		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">qcount</span><span style="color:#f92672">--</span>
		<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>)
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">true</span>
	}
	<span style="color:#75715e">// 非阻塞直接返回
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">block</span> {
		<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>)
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">false</span>
	}

	<span style="color:#75715e">// 阻塞
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">gp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()
	<span style="color:#a6e22e">mysg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">acquireSudog</span>()
	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvq</span>.<span style="color:#a6e22e">enqueue</span>(<span style="color:#a6e22e">mysg</span>)			<span style="color:#75715e">// 入 recvq 队
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">gopark</span>(<span style="color:#a6e22e">chanparkcommit</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>), <span style="color:#a6e22e">waitReasonChanReceive</span>, <span style="color:#a6e22e">traceEvGoBlockRecv</span>, <span style="color:#ae81ff">2</span>)	<span style="color:#75715e">// 阻塞
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>, <span style="color:#a6e22e">success</span>
}
</code></pre></div><p><strong>总结</strong></p>
<ul>
<li>可以向 closed channel 接受值，若其 buf 为空，则返回零值。若其 buf 不为空，正常返回</li>
<li>无缓冲 channel 接受消息，是由另一个 goroutine 里的栈直接拷贝过来的</li>
<li>有缓冲 channel 总是取 buf 队首消息，但如果 sendq 不为空，还需要把 sendq 需要发送的消息拷贝到 buf 中</li>
</ul>
<h2 id="channel-vs-mutex">channel vs mutex <a href="#channel-vs-mutex" class="anchor">🔗</a></h2><blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<p>上述思想实际上就是并发编程中的 <strong>共享内存模型</strong> VS <strong>CSP 信息传递模型</strong>，更具体的说： <strong>mutex</strong> VS <strong>channel</strong>，Go 是第一个引入 CSP 思想并且发扬光大的语言。那这是不是意味着我们在编程中要摒弃 mutex，全部使用 channel 呢？既然 Go 设计者这么推崇 CSP， 为什么 Go 中还是有 mutex 包呢？</p>
<p>channel 与 mutex 侧重点不一样，channel 侧重于协程之间传递数据，mutex 用来保护并发数据</p>
<p>适用于 channel 的场景：</p>
<ol>
<li>传递数据的所有权，即把某个数据发送给其他协程</li>
<li>分发任务，每个任务都是一个数据</li>
<li>交流异步结果，结果是一个数据</li>
</ol>
<p>适用于 mutex 的场景：</p>
<ol>
<li>缓存</li>
<li>状态</li>
</ol>
<p>实际上，channel 的底层数据结构中也利用 mutex 保护数据，但是适用于 mutex 的场景去使用 channel 性能会差一些。</p>
<p>更具体的我们可以根据下图进行判断</p>
<p><p class="markdown-image">
  <img src="http://ganghuan.oss-cn-shenzhen.aliyuncs.com/img/2de7743a1386dec3af56f6903af7bfde_482x309-2021-11-30.png" alt="img"  />
</p></p>
<p><strong>channel 实际场景</strong></p>
<ol>
<li>超时控制/定时任务</li>
<li>并发控制</li>
<li>解耦生产者，消费者</li>
<li>&hellip;</li>
</ol>
<p><strong>总结</strong></p>
<ol>
<li>channel 不是银弹，该用 mutex 就用 mutex</li>
<li>channnel 用于关注数据流动，mutex 保护固定数据</li>
</ol>
<h2 id="参考">参考 <a href="#%e5%8f%82%e8%80%83" class="anchor">🔗</a></h2><ol>
<li><a href="https://github.com/golang/go/blob/5786a54cfe34069c865fead1b6d9c9e3485a40a5/src/runtime/chan.go" target="_blank" rel="noopener">https://github.com/golang/go/blob/5786a54cfe34069c865fead1b6d9c9e3485a40a5/src/runtime/chan.go</a></li>
<li><a href="https://www.bookstack.cn/read/qcrao-Go-Questions/channel-%E4%BB%80%E4%B9%88%E6%98%AF%20CSP.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/qcrao-Go-Questions/channel-%E4%BB%80%E4%B9%88%E6%98%AF%20CSP.md</a></li>
<li><a href="https://www.cnblogs.com/qcrao-2018/p/11220651.html" target="_blank" rel="noopener">https://www.cnblogs.com/qcrao-2018/p/11220651.html</a></li>
</ol>

    </div>

    
        <div class="tags">
            
                <a href="https://he2121.github.io/xiaohe-blog/tags/golang">golang</a>
            
        </div>
    
    
    

</section>

<script src="https://utteranc.es/client.js"
        repo="he2121/xiaohe-blog"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>


    </main>
    
    <footer id="footer">
    
        <div id="social">


    <a class="symbol" href="https://github.com/he2121/" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28"  viewBox="0 0 72 72" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    
    <title>Github</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)">
            <g id="Github" transform="translate(264.000000, 939.000000)">
                <path d="M8,72 L64,72 C68.418278,72 72,68.418278 72,64 L72,8 C72,3.581722 68.418278,-8.11624501e-16 64,0 L8,0 C3.581722,8.11624501e-16 -5.41083001e-16,3.581722 0,8 L0,64 C5.41083001e-16,68.418278 3.581722,72 8,72 Z" id="Rounded" fill="#bbbbbb"></path>
                <path d="M35.9985,13 C22.746,13 12,23.7870921 12,37.096644 C12,47.7406712 18.876,56.7718301 28.4145,59.9584121 C29.6145,60.1797862 30.0525,59.4358488 30.0525,58.7973276 C30.0525,58.2250681 30.0315,56.7100863 30.0195,54.6996482 C23.343,56.1558981 21.9345,51.4693938 21.9345,51.4693938 C20.844,48.6864054 19.2705,47.9454799 19.2705,47.9454799 C17.091,46.4500754 19.4355,46.4801943 19.4355,46.4801943 C21.843,46.6503662 23.1105,48.9634994 23.1105,48.9634994 C25.2525,52.6455377 28.728,51.5823398 30.096,50.9649018 C30.3135,49.4077535 30.9345,48.3460615 31.62,47.7436831 C26.2905,47.1352808 20.688,45.0691228 20.688,35.8361671 C20.688,33.2052792 21.6225,31.0547881 23.1585,29.3696344 C22.911,28.7597262 22.0875,26.3110578 23.3925,22.9934585 C23.3925,22.9934585 25.4085,22.3459017 29.9925,25.4632101 C31.908,24.9285993 33.96,24.6620468 36.0015,24.6515052 C38.04,24.6620468 40.0935,24.9285993 42.0105,25.4632101 C46.5915,22.3459017 48.603,22.9934585 48.603,22.9934585 C49.9125,26.3110578 49.089,28.7597262 48.8415,29.3696344 C50.3805,31.0547881 51.309,33.2052792 51.309,35.8361671 C51.309,45.0917119 45.6975,47.1292571 40.3515,47.7256117 C41.2125,48.4695491 41.9805,49.9393525 41.9805,52.1877301 C41.9805,55.4089489 41.9505,58.0067059 41.9505,58.7973276 C41.9505,59.4418726 42.3825,60.1918338 43.6005,59.9554002 C53.13,56.7627944 60,47.7376593 60,37.096644 C60,23.7870921 49.254,13 35.9985,13" fill="#FFFFFF"></path>
            </g>
        </g>
    </g>
</svg>
    </a>


</div>

    

    <div class="copyright">
    
       © Copyright 
       2021 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       小贺
    
    </div>

    
      <div class="powerby">
        Powered by <a href='http://www.gohugo.io/'>Hugo</a> Theme By <a href='https://github.com/nodejh/hugo-theme-cactus-plus'>nodejh</a>
      </div>
    
</footer>



  </body>
</html>
