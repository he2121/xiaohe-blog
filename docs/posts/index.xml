<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 小贺的博客</title>
    <link>https://he2121.github.io/xiaohe-blog/posts/</link>
    <description>Recent content in Posts on 小贺的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 10 Nov 2021 18:33:24 +0800</lastBuildDate><atom:link href="https://he2121.github.io/xiaohe-blog/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MySQL binlog 设计介绍</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/mysqlbinlog%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Wed, 10 Nov 2021 18:33:24 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/mysqlbinlog%E8%AE%BE%E8%AE%A1/</guid>
      <description>通过这篇文章你能了解到的知识 🔗 binlog 是什么 binlog 的作用 binlog 的三种类型，以及各自优缺点 binlog 文件的结构与内容  binlog 是什么 🔗Binary Log，顾名思义是一种二进制格式的日志。具体来说，binlog 日志是一组包含了对 MySQL server 实例进行数据修改（update/delete/insert/...）信息的文件。
binlog 作用 🔗 用于复制，如主从复制 数据恢复  binlog 类型 🔗 基于语句 (Statement-based)的日志记录 (SBL): 事件包含产生数据变化的SQL语句。 基于行 (Row-based) 的日志记录(RBL): 描述单个行的变化 混合 (Mixed)：上述两者结合使用, 以 SBL 为主，特殊情况下切换到 RBL  binlog 为什么会有这三种类型？
一开始只有 statement-based，但 statement-based 存在不少问题，后面才有的 row 与 mixed。
SBL 优点 🔗 产生的日志文件少， io 次数少  SBL 缺点 🔗  在一些不安全的语句上，主从复制做不到数据一致，比如
  含有系统函数的语句，可能会在副本上返回不同的值，如 RAND(), USER(),UUID(), SYSDATE() .</description>
    </item>
    
    <item>
      <title>Convert资源集合</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/convert%E8%B5%84%E6%BA%90%E9%9B%86%E5%90%88/</link>
      <pubDate>Wed, 10 Nov 2021 00:38:28 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/convert%E8%B5%84%E6%BA%90%E9%9B%86%E5%90%88/</guid>
      <description>json2go 🔗 https://mholt.github.io/json-to-go/  sql2go 🔗 https://sql2go.ricestdiotech.com/  curl2go 🔗 https://mholt.github.io/curl-to-go/  curl2all 🔗 https://curlconverter.com/  yaml2go 🔗 https://yaml2go.prasadg.dev/  toml2go 🔗 https://xuri.me/toml-to-go/  数据转换大集合(json、xml、html、yaml、toml、csv、xlsx、png、pdf&amp;hellip;) 🔗 https://www.convertsimple.com/  sql2es 🔗 https://sqltoelasticsearch.azurewebsites.net/  time convert 🔗 https://www.epochconverter.com/  base 64 encode/decode 🔗 https://www.base64decode.org/  欢迎评论补充 🔗- ...  </description>
    </item>
    
    <item>
      <title>Golang 常用日志库介绍</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/golang%E6%97%A5%E5%BF%97%E5%BA%93%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Tue, 09 Nov 2021 14:30:12 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/golang%E6%97%A5%E5%BF%97%E5%BA%93%E4%BB%8B%E7%BB%8D/</guid>
      <description>前言 🔗为什么需要日志 🔗 调试开发 程序运行日志 用户行为日志  不同的目的决定了日志输出的格式、频率。作为开发人员，调试开发阶段打印日志目的是输出尽可能全的信息（如上下文，变量值&amp;hellip;），辅助开发测试，因此日志格式要易读，打印频率要高。而在程序运行时，日志格式倾向于结构化（便于分析与搜索），而且为了性能和聚焦于关键信息（如error ），打印频率更偏低。
Go 标准库 Log 🔗使用 🔗我们常使用 Go log 以下三组函数：
 Print/Printf/Println : 打印日志信息  Panic/Panicf/Panicln : 打印日志信息后，以拼装好的字符串为参数调用 Panic  Fatal/Fatalf/Fatalln : 打印日志信息后，os.Exit(1) 退出程序  带 f 后缀的是格式化输出，ln 后缀增加换行符，不过在打印日志场景中会自动增加一个换行符，这里 ln 后缀差别不大。Panic 与 Fatal 的区别在于 Panic 可以被捕获。
示例如下:
package main import &amp;#34;log&amp;#34; func main() { log.Println(&amp;#34;日志信息1&amp;#34;) log.Print(&amp;#34;日志信息2&amp;#34;) log.Panicln(&amp;#34;日志信息3&amp;#34;) log.Fatalln(&amp;#34;日志信息4&amp;#34;) // 运行不到 } 2021/11/09 15:41:34 日志信息1 2021/11/09 15:41:34 日志信息2 2021/11/09 15:41:34 日志信息3 panic: 日志信息3 goroutine 1 [running]: log.</description>
    </item>
    
    <item>
      <title>Go 反射解析与实战</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/go-%E5%8F%8D%E5%B0%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/</link>
      <pubDate>Mon, 30 Aug 2021 17:10:12 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/go-%E5%8F%8D%E5%B0%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/</guid>
      <description>前言 🔗日常写业务时，我们很少会用到反射，导致大部分人对 go 的反射还比较陌生。 虽然并不推荐在业务代码中写反射代码，但是了解它，能够让我们更好的去理解许多框架的逻辑，以及能够让自己具备有初步实现一个通用第三方 SDK 的能力。
什么是反射 🔗 在计算机学中，反射是指计算机程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。
 来自维基百科
在 Golang 中，其实就是编译时是 interface{}，不知道其具体的类型，要在运行中反射获取类型、更新检查他们的值、
执行它们的方法，
反射能够干什么 🔗反射是元编程的一个关键策略
 java spring golang json 序列化与反序列化 go orm 框架 &amp;hellip;  反射的缺点 🔗 性能 可读性 go 作为静态语言，编译时能检查出不少问题，但反射跳过这检查，可能在运行中 panic  Golang 反射解析 🔗要搞清楚反射，得先简要了解一下 interface
Interface 🔗定义 🔗接口有两种定义：
  eface: 空接口定义, 包含具体类型与数据
  iface: 非空接口定义（实现了方法的接口），
  // 位于 src/runtime/runtime2.go type eface struct { _type *_type	// 具体的类型 	data unsafe.Pointer	// 数据 } type iface struct { tab *itab	// 指向itab 的指针 	data unsafe.</description>
    </item>
    
  </channel>
</rss>
