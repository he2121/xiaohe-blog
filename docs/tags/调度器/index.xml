<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>调度器 on 小贺的博客</title>
    <link>https://he2121.github.io/xiaohe-blog/tags/%E8%B0%83%E5%BA%A6%E5%99%A8/</link>
    <description>Recent content in 调度器 on 小贺的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 17 Nov 2021 14:30:00 +0800</lastBuildDate><atom:link href="https://he2121.github.io/xiaohe-blog/tags/%E8%B0%83%E5%BA%A6%E5%99%A8/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang 协程与调度器原理</title>
      <link>https://he2121.github.io/xiaohe-blog/posts/golang%E5%8D%8F%E7%A8%8B%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 17 Nov 2021 14:30:00 +0800</pubDate>
      
      <guid>https://he2121.github.io/xiaohe-blog/posts/golang%E5%8D%8F%E7%A8%8B%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86/</guid>
      <description> 思考从容器上该如何设置 GOMAXPROCS 大小引发，这个数字设置多少合理，其到底限制了什么，cpu 核数，系统线程数还是协程数？
 背景 🔗Go 语言可以说为并发而生。Go 从语言级别支持并发，通过轻量级协程 Goroutine 来实现程序并发运行，go关键字的强大与简洁是其它语言不可及的，接下来让我们一起来探索 Golang 中 Goroutine 与协程调度器设计的一些原理吧。
Go 协程 🔗协程调度器 🔗参考 🔗 https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit https://stackoverflow.com/questions/68312082/when-will-go-scheduler-create-a-new-m-and-p https://cloud.tencent.com/developer/article/1819618 https://yizhi.ren/2019/06/03/goscheduler/ https://segmentfault.com/a/1190000040710568  </description>
    </item>
    
  </channel>
</rss>
